## [ 카운팅 정렬 ]

- 항목들의 순서를 결정하기 위해 집합에 각 항목에 몇 개씩 있는지 세는 작업을 하여,
- 선형 시간에 정렬하는 효율적인 알고리즘
- 제한사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.
- 시간 복잡도 : O(n+k) : n은 리스트 길이, k는 정수의 최대값

```python
[0,4,1,3,1,2,4,1]을 카운팅 정렬하는 과정 → 0 ~ 4의 정수로 구성

1단계)
- Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
DATA   0 4 1 3 1 2 4 1 -> 0:1개, 1:3개, 2:1개, 3:1개, 4:2개 -> COUNTS에 담기
COUNTS 0 0 0 0 0 ->
COUNTS 1 3 1 1 2 -> Data의 정수를 각 인덱스 자리에 저장(COUNTS[0] 1개, COUNTS[1] 3개, ...)

2단계)
- 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다
DATA   0 4 1 3 1 2 4 1
COUNTS 1 3 1 1 2 ->
COUNTS 1 4 5 6 8 -> 위의 COUNTS[0] = 1 / COUNTS[0] + COUNTS[1] = 4 / COUNTS[1] + COUNTS[2] = 5, ...

3단계)
- counts[1]을 감소시키고 Temp에 1을 삽입한다.
DATA    0 4 1 3 1 2 4 1
COUNTS [1->0] [4->3->2] [5->4] [6->5] [8->7->6]
TEMP   [0] [1] [1] [1] [2] [3] [4] [4]
- Temp 업데이터 완료하고 정렬 작업 종료한다.
```

```python
# 카운팅 정렬 과정
N = 6
K = 9 # 0~K
data = [7, 2, 4, 5, 2, 3] # 0~9, K=9
counts = [0] * (K+1)
temp = [0] * N
# counts 배열에 기록하기
for x in data:
    counts[x] += 1
# counts 누적합 구하기
for i in range(1, K+1):
    counts[i] = counts[i-1] + counts[i]
# data의 마지막 원소부터 정렬하기
for i in range(N-1, -1, -1): # N-1 -> 0번 인덱스
    counts[data[i]] -= 1 # 개수를 인덱스로 변환(남은 갯수 계산)
    temp[counts[data[i]]] = data[i]
print(*temp) # 2 2 3 4 5 7
```

---

## [ Baby-gin Game ]

- 설명
    - 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
    - 그리고 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin이라 부른다.
    - 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램 작성
- 입력 예
    - 667767은 두개의 triplet이므로 baby-gin (666, 777)
    - 054060은 한개의 run과 한개의 triplet이므로 역시 baby-gin (456, 000)

---

## [ 완전 검색 ]

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만(단점), 해답을 찾아내지 못할 확률이 작다(장점)
- Baby-gin Game - 고려할 수 있는 모든 경우의 수 생성하기
    - 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)
    - 예시) 입력으로 [2,3,5,7,7,7]을 받았을 경우, 모든 경우의 순열을 생성
    - 예시) [1,2,3]을 포함하는 모든 순열을 생성하는 함수
    
    ```python
    for i1 in range(1, 4):
    	for i2 in range(1, 4):
    		if i2 != i1:
    			for i3 in range(1, 4):
    				if i3 != i1 and i3 != i2:
    					print(i1, i2, i3)
    ```
    

---

## [ 탐욕 알고리즘 ( 그리디 )]

- 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 선택해야 할 때 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 탐욕 알고리즘의 동작 과정
    1. 해 선택 - 최적 해를 구한 뒤, 부분 해 집합에 추가
    2. 실행 가능성 검사 - 문제의 제약 조건을 위반하지 않는지 검사
    3. 해 검사 - 문재의 해가 되는지 확인
- 예시) 거스름돈 줄이기
    - 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일까?
    - 해 선택 : 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어든다
    
    ```python
    # 탐욕 알고리즘으로 Baby Gin 풀이
    
    num = 456789 # Bab Gin 확인할 6자리 수
    c = [0] * 12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
    
    for i in range(6):
        c[num % 10] += 1
        num //= 10
    
    i = 0
    tri = run = 0
    while i < 10:
        if c[i] >= 3: # triplete 조사 후 데이터 삭제
            c[i] -= 3
            tri += 1
            continue
        # run 조사 후 데이터 삭제
        if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            run += 1
            continue
        i += 1
    if run + tri == 2:
        print('Baby Gin')
    else:
        print('Lose')
    ```