- **부분 집합** : 집합에 포함된 원소들을 선택하는 것
- 아무것도 선택하지 않은 경우도 집합에 포함된다 ( = 공집합 )
- 구현 방법
    1. 완전 탐색 : 학습용
    2. Binary Counting : 부분 집합이 필요할 때 사용하는 방법
- **바이너리 카운팅** : 원소 수에 해당하는 N개의 비트열을 이용( tar >>= 1 : 검사한 한 자리를 제거 )

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d19f9ad3-44f2-4548-913d-7640fdb34526/76563dcb-7319-4b5d-9b94-f9005760b1ce/Untitled.png)

[ 연습문제 ]

친구 A, B, C, D, E가 있다. 이 중 최소 2명 이상의 친구를 선정하는 경우의 수는?

```python
arr = ['A', 'B', 'C', 'D', 'E']
n = len(arr)

def get_count(tar):
    cnt = 0
    for i in range(n):
        # 1비트가 1인지 확인
        if tar & 0x1:
            cnt += 1
        # right shift 비트 연산자 -> 오른쪽 끝 비트를 하나씩 제거
        tar >>= 1
    return cnt
result = 0
for tar in range(1 << n):
    if get_count(tar) >= 2: # bit가 2개 이상 1이라면 -> 2명 이상이라면
        result += 1
print(result) # 26
```

---

- **조합** : 서로 다른 N개의 원소 중 r개를 **순서없이** 고르는 골라낸 것

→ N의 개수가 많아지면 **재귀호출 구현 필요**

[ 연습문제 ]

주사위 3개로 나올 수 있는 모든 눈금을 출력하시오

```python
N = 3
path = []

def func(lev, start):
    if lev == N:
        print(path)
        return

    for i in range(7):
        path.append(i)
        func(lev + 1, i)
        path.pop()
func(0, 1)
'''
[0, 0, 0]
~
[6, 6, 6]
'''
```

---

- **Greedy** : 결정이 필요할 때, 현재 기준으로 **가장 좋아 보이는 선택지**로 결정하여 답을 도축

[ 연습문제 1 ]

동전교환 - 1730원을 최소 동전 수로 거슬러 주면 몇 개인가?

```python
coin_list = [500, 100, 50, 10]
tar = 1730

cnt = 0
for coin in coin_list:
	possible_cnt = tar // coin # 사용 가능한 동전의 수 (만약 500원이라면 3개 가능)

	cnt += possible_cnt # 3개 추가
	tar -= coin * possible_cnt # 3개로 만든 금액인 1500원을 뺀다
print(cnt)
```

[ 연습문제 2 ]

화장실 사용 시간이 다음과 같다. 대기 시간의 누적 합이 최소로 되는 경우는?

→ [ A : 15분 / B : 30분 / C : 50분 / D : 10분 ]

```python
person = [15, 30, 50, 10]
n = len(person)
person.sort()
sum = 0
left_person = n-1 # 화장실을 이용 못한 대기자 수

for turn in range(n):
    time = person[turn]
    # 누적합 += 남은 사람 * 시간
    sum += left_person * time
    left_person -= 1
print(sum) # 90
```

[ 연습문제 3 ]

도둑은 최대 30kg 까지 짐을 담을 수 있다. 물건의 개수(N), 물건 무게(W), 가격(P)일 때, 최대 수익?

→ Kg 당 가격이 가장 높은 물건을 담으면 된다

```python
n = 3
target = 30
things = [(5, 50), (10, 60), (20, 140)] # (Kg, Price)

things.sort(key = lambda x : (x[1] / x[0]), reverse=True)
sum = 0
for kg, price in things:
	per_price = price / kg
	# 만약 가방에 남은 용량이 얼마 없다면, 물건을 잘라 넣고 끝난다
	if target < kg:
		sum += target + per_price
		break
	sum += price
	target -= kg

print(int(sum)) # 201
```

[ 연습문제 4 ]

여러 팀들이 원하는 회의실 예약 시간이 주어질 때, 가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야 할까?

[ 오름차순 정렬 → (1, 4) (3, 5) (1, 6) (5, 7) (3, 8) (5, 9) (6, 10) (8, 11) (2, 13) (12, 14) ]

< 문제 풀이 >

1. 가장 일찍 시작하는 것
2. 끝나는 시간이 짧은 것

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d19f9ad3-44f2-4548-913d-7640fdb34526/d3da3503-df9b-4cd4-a447-201937eea501/Untitled.png)