### [ 알고리즘 설계 기법의 종류 ]

1. 완전 탐색 ( Brute Force ) - 전체를 그냥 다 보자
    - 배열 : for문, while문
    - 그래프 ( 관계가 있는 데이터 ) - BFS, DFS

— 완전 탐색을 구현하면, 시간 or 메모리 초과가 되더라! —

1. 그리디 ( Greedy ) - 상황마다 좋은 걸 고르자
    - 규칙 + 증명 → 구현
2. DP ( Dynamic Programming ) - 큰 문제를 작은 문제로 나누어 부분적으로 해결하자
    - 분할 정복과 다르게 작은 문제가 중복된다
    - Memoization - 중복된 문제의 해답을 저장해놓고 재활용하자!
3. 분할 정복 - 큰 문제를 작은 문제로 나누어 부분적으로 해결하자
4. 백트래킹 ( Backtracking ) - 전체 중 가능성 없는 것을 빼자!

---

## < 분할 정복 >

- Top-down approach
    - 분할은 나눌 수 없을 때까지 ( 1일 때까지 ) 분할한 후,
    - 제일 작은 부분의 해를 구함

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d19f9ad3-44f2-4548-913d-7640fdb34526/9aa6f1a0-a1ae-4995-be33-89bcbf3cc983/Untitled.png)

- 자연수 C의 n 제곱 값을 구하는 함수를 구현해보자.
    - 분할 정복 기반의 알고리즘 : O(log₂n)
    - C의 8제곱 = C x C x C x C x C x C x C x C
    - C의 8제곱 = C⁴ x C⁴ = (C⁴)² = ((C²)²)²) → 분할 과정

---

## [ 병합 정렬 (Merge sort) ]

- 외부 정렬의 기본이 되는 정렬 알고리즘
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용
    - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
    - top-down 방식
- 시간 복잡도 : O(n log n)

→ 분할 단계 : 전체 자료 집합에 대하여 최소 크기의 부분집합이 될 때까지(log n) 분할 작업 계속

→ 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합(n)

```python
# 분할 과정
merge_sort(LIST m)
	if length(m) == 1 : RETURN m
	LIST left, right
	middle <- length(m) / 2
	FOR x in m before middle
		add x to left
	FOR x in m after or equal middle
		add x to right
	left <- merge_sort(left)
	right <- merge_sort(right)
	RETURN merge(left, right)
	
# 병합 과정
merge(LIST left, LIST right)
	LIST result
	WHILE length(left) > 0  OR length(right) > 0
		IF length(left) > 0 AND length(right) > 0
			IF first(left) <= first(right)
				append popfirst(left) to result
			ELSE
				append popfirst(right) to result
		ELIF length(left) > 0
			append posfirst(left) to result
		ELIF length(right) > 0
			append posfirst(right) to result
	RETURN result
```

```python
# 5204_병합 정렬
def merge_sort(arr): # 분할 과정
    if len(arr) == 1:
        return arr
    mid = len(arr) // 2  # 중간값
    left = [] # mid의 왼쪽값
    right = [] # mid의 오른쪽값
    for i in arr[:mid]:
        left.append(i)
    for j in arr[mid:]:
        right.append(j)
    left_lst = merge_sort(left)
    right_lst = merge_sort(right)
    return merge(left_lst, right_lst)

def merge(left, right): # 병합 과정
    global cnt
    # 왼쪽 마지막 원소가 오른쪽 마지막 원소보다 큰 경우의 수
    if left[-1] > right[-1]:
        cnt += 1
    result = []

    i = j = 0
    # 왼쪽과 오른쪽에 요소가 있다면
    while len(left) > i and len(right) > j:
        # 값을 비교하여 작은 것을 삽입
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    # 한 쪽만 남았다면 그대로 result에 삽입
    while len(left) > i:
        result.append(left[i])
        i += 1
    while len(right) > j:
        result.append(right[j])
        j += 1
    return result

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    A = list(map(int, input().split())) # [2, 2, 1, 1, 3]
    cnt = 0
    answer = merge_sort(A) # answer에 할당해주어야 한다
    print(f'#{test_case} {answer[N//2]} {cnt}') #1 2 0
```

---

## [ 퀵 정렬 (Quick sort) ]

- 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘
- 같은 점 : 주어진 배열을 두 개로 분할하고 각각을 정렬한다.
- 다른 점 : 기준 아이템(pivot item) 중심으로 분할 + ‘병합’이란 후처리 작업이 필요하지 않다.
- 아이디어
    - Pivot 값들보다 큰 값은 오른쪽, 작은 값은 왼쪽 집합에 위치하도록 한다
    - Pivot을 두 집합의 가운데에 위치시킨다

```python
quicksort(A[], L, r):
	if L < r
		s <- partition(a, L, r)
		quicksort(A[], L, s-1)
		quicksort(A[], s+1, r)

# 1번. Hoare-Partition 알고리즘
partition(A[], L, r):
	p <- A[L] # p : 피봇 값
	i <- L, j <- r
	WHILE i <= j
		WHILE A[i] <= p : i++ # p보다 큰 값을 만날때까지
		WHILE A[j] >= p : j-- # p보다 작은 값을 만날때까지
		IF i < j : swap(A[i], A[j]) # 위치 바꾸기
	swap(A[L], A[j]) # P 자리를 찾아줌
	REUTRN j

# 2번. Lomuto partition 알고리즘
partition(A[], p, r):
	x <- A[r]
	i <- p-1
	FOR j in p -> r-1
		IF A[j] <= x
			i++, swap(A[i], A[j])
		swap(A[i+1], A[r])
		RETURN i+1
```

```python
# 퀵 정렬 구현 1
def quick(arr, left, right): # arr: [2, 2, 1, 1, 3], left: 0, right: 4
    if left < right: # 시작점과 끝점이 교차하지 않았다면
        mid = partition(arr, left, right)
        quick(arr, left, mid-1) # pivot 기준 왼쪽 값 정렬
        quick(arr, mid, right) # pivot 기준 오른쪽 값 정렬

def partition(arr, left, right):
    # 문제의 원인 : arr[N//2] -> 피벗을 배열의 중간값으로 선택
    pivot = arr[(left + right) // 2] # pivot: 1 = arr[2]
    while left <= right:
        while arr[left] < pivot:
            left += 1 # p보다 큰 값을 만날때까지
        while arr[right] > pivot:
            right -= 1 # p보다 작은 값을 만날때까지
        if left <= right:
            arr[left], arr[right] = arr[right], arr[left]
            left, right = left + 1, right - 1
    return left # 중간값

T = int(input())
for test_case in range(1, T+1):
    N = int(input())
    A = list(map(int, input().split())) # [2, 2, 1, 1, 3]
    quick(A, 0, N-1)
    print(f'#{test_case} {A[N//2]}') #1 2
```

```python
# 퀵 정렬 구현 2
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x <= pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = list(map(int, input().split())) # [2, 2, 1, 1, 3]
    print(f'#{tc}', quick_sort(arr)[N//2]) #1 2
```

---

## < 이진 탐색 (Binary search) >

- 정렬된 데이터를 기준으로 특정 값이나 범위를 검색하는데 사용
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다

```python
# 이진 검색
arr = [324, 32, 22114, 16, 48, 93, 422, 21, 316]

# 1. 정렬된 상태의 데이터
arr.sort()

# 2. 이진 검색 - 반복문 버전
def binarySearch(target):
    # 제일 왼쪽, 오른쪽 인덱스 구하기
    low = 0
    high = len(arr) - 1
    # 탐색 횟수
    cnt = 0
    # 해당 숫자를 찾으면 종료
    # 더이상 쪼갤 수 없을 때까지 반복
    while low <= high:
        mid = (low + high) // 2
        cnt += 1
        # 가운데 숫자가 정답이면 종료
        if arr[mid] == target:
            return mid, cnt
        elif arr[mid] > target:
            high = mid - 1
        elif arr[mid] < target:
            low = mid + 1
    # 못찾았으면 -1 반환
    return -1, cnt

# 인덱스 위치, 탐색 횟수
print(f'21 = {binarySearch(21)}') # 21 = (1, 2)
print(f'324 = {binarySearch(324)}') # 324 = (6, 2)
print(f'888 = {binarySearch(888)}') # 888 = (-1, 4)
```

```python
# 이진 검색
arr = [324, 32, 22114, 16, 48, 93, 422, 21, 316]

# 1. 정렬된 상태의 데이터
arr.sort()

# 2. 이진 검색 - 재귀 함수
def binarySearch(low, high, target):
    # 기저조건(언제까지 재귀가 반복되어야 할까?)
    if low > high:
        return -1
    # 다음 재귀 들어가기 전엔 무엇을 해야할까?
    # 정답 판별
    mid = (low + high) // 2
    if target == arr[mid]:
        return mid
    # 다음 재귀 함수 호출(파라미터)
    if target < arr[mid]:
        return binarySearch(low, mid-1, target)
    else:
        return binarySearch(mid+1, high, target)
    # 재귀 함수에서 돌아왔을 때 어떤 작업을 해야할까?

print(f'21 = {binarySearch(0, len(arr)-1, 21)}') # 21 = (1, 2)
print(f'324 = {binarySearch(0, len(arr)-1, 324)}') # 324 = (6, 2)
print(f'888 = {binarySearch(0, len(arr)-1, 888)}') # 888 = (-1, 4)
```

- [이진 검색을 활용한 심화 학습 키워드] → Lower Bound, Upper Bound