## < 최소 비용 신장 트리 (MST) >

- 최소 비용 문제
    - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
    - 두 정점 사이의 최소 비용의 경로 찾기
- 최소 신장 트리
    - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

- 간선의 개수를 최소화하여 모든 정점을 연결하는 방법( 신장 트리 )
    - 여러가지 방법이 있다
    - 싸이클이 발생하지 않는다
    - 간선의 개수 : (V - 1)개
    
    → 최소 비용 신장 트리 구하는 방법!
    
    - 완전 탐색 : 시간적으로 너무 많이 걸림 ( X )
    - 제일 작은 것 부터? (18, 21, 25, …)
    - 특정 노드를 시작으로 갈 수 있는 곳들 중, 작은 곳으로

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d19f9ad3-44f2-4548-913d-7640fdb34526/eb4dcedc-a622-4375-9352-4b59e9dc7fb2/Untitled.png)

---

## [ Prim 알고리즘 ]

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
    - 임의 정점을 하나 선택하기
    - 선택한 정점과 인접하는 정점들 중(우선순위 큐), 최소 비용의 간선이 존재하는 정점을 선택

```python
'''
노드 : 7개, 간선 : 11개
7 11
0 1 32
0 2 31
0 5 60
0 6 51
1 2 21
2 4 46
2 6 25
3 4 34
3 5 18
4 5 40
4 6 51
'''

# 우선순위 큐
from heapq import heappush, heappop

def prim(start):
    pq = []
    MST = [0] * V # 방문 표시
    sum_weight = 0 # 최소 비용
    # [PRIM] 가중치가 낮으면 먼저 나와야 한다
    # -> 관리해야할 데이터: 가중치, 노드 번호 2가지
    # -> 동시에 두 가지 데이터 다루기
    # 1. class 만들기(여러개) / 2. tuple 만들기(한두개)
    heappush(pq, (0, start)) # 시작점 추가
    while pq:
        weight, now = heappop(pq)
        # 우선순위 큐의 특성 상
        # 더 먼거리로 가는 방법이 큐에 저장이 되기 때문에
        # 기존에 이미 더 짧은 거리로 방문했다면, continue
        if MST[now]: # 방문했다면 continue
            continue
        MST[now] = 1 # 방문 처리
        sum_weight += weight # 누적합 추가
        for to in range(V): # 갈 수 있는 노드들을 보면서
            # 갈 수 없거나 이미 방문했다면 Pass
            if graph[now][to] == 0 or MST[to]:
                continue
            heappush(pq, (graph[now][to], to))
    print(f'최소 비용: {sum_weight}') # 최소 비용: 175

V, E = map(int, input().split())
# 인접 행렬로 저장
graph = [[0] * V for _ in range(V)]
for _ in range(E):
    s, e, w = map(int, input().split())
    # [가중치 그래프] s -> e로 가는데 w이라는 비용이 든다
    graph[s][e] = w
    graph[e][s] = w # 무방향 그래프
prim(0)
```

---

## [ Kruskal 알고리즘 ]

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
    1. 모든 간선을 가중치에 따라 오름차순으로 정렬
    2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴

```python
'''
노드 : 7개, 간선 : 11개
7 11
0 1 32
0 2 31
0 5 60
0 6 51
1 2 21
2 4 46
2 6 25
3 4 34
3 5 18
4 5 40
4 6 51
'''
# 1. 전체 그래프를 보고, 가중치가 제일 작은 간선부터 뽑자
# -> 코드로 구현 : 전체 간선 정보를 저장 + 가중치로 정렬
# 2. 방문 처리
# -> 이 때, 싸이클이 발생하면 안된다
# -> 싸이클 여부 => union-find 알고리즘 활용

def find_set(x):
    if parents[x] == x:
        return x
    # 경로 압축
    parents[x] = find_set(parents[x])
    return parents[x]

def union(x, y):
    x = find_set(x)
    y = find_set(y)
    if x == y: # 같은 집합이면 Pass
        return
    if x < y:
        parents[y] = x
    else:
        parents[x] = y

V, E = map(int, input().split())
edges = [] # 간선 정보들을 모두 저장
for _ in range(E):
    s, e, w = map(int, input().split())
    edges.append([s, e, w])
edges.sort(key=lambda x: x[2]) # 가중치 기준으로 정렬
parents = [i for i in range(V)] # 대표자 배열

cnt = 0 # 간선의 개수가 V - 1개 일 때
sum_weught = 0
for s, e, w in edges: # 간선들을 모두 확인한다
    # 싸이클이 발생하면 Pass
    # -> 이미 같은 집합에 속해 있다면 Pass
    if find_set(s) == find_set(e):
        continue
    # 싸이클이 없으면 방문 처리
    print(s, e, w)
    cnt += 1
    union(s, e)
    sum_weught += w
    if cnt == V - 1: # 간선의 개수 == V - 1
        break
print(f'최소 비용: {sum_weught}')

'''
3 5 18
1 2 21
2 6 25
0 2 31
3 4 34
2 4 46
최소 비용: 175
'''
```

---

## [ 최단 경로 ]

- 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중, 간선의 가중치의 합이 최소인 경로
    - 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d19f9ad3-44f2-4548-913d-7640fdb34526/4e8140df-1dd5-468f-9116-7d2de694d7a4/Untitled.png)

```python
'''
6 8
0 1 2
0 2 4
1 2 1
1 3 7
2 4 3
3 4 2
3 5 1
4 5 5
'''

INF = int(1e9) # 1e9 : 10억

from heapq import heappush, heappop
V, E = map(int, input().split())
start = 0 # 시작 노드 번호
# 인접 리스트
graph = [[] for _ in range(V)]
# 누적 거리를 저장할 변수
distance = [INF] * V
# 간선 정보 저장
for _ in range(E):
    s, e, w = map(int, input().split())
    graph[s].append([w, e])

def dijkstra(start):
    pq = []
    # 시작점의 weight, node 번호를 한 번에 저장
    heappush(pq, (0, start))
    # 시작 노드 초기화
    distance[start] = 0

    while pq:
        # 최단 거리 노드에 대한 정보
        dist, now = heappop(pq)
        # pq의 특성 때문에 더 긴거리가 미리 저장되어 있음
        # now가 이미 더 짧은 거리로 온 적 있다면 Pass
        if distance[now] < dist:
            continue
        # now에서 인접한 다른 노드 확인
        for to in graph[now]:
            next_dist = to[0]
            next_node = to[1]
            # 누적 거리 계산
            new_dist = dist + next_dist
            # 이미 더 짧은 거리로 간 경우 Pass
            if new_dist >= distance[next_node]:
                continue
            # 누적 거리를 최단 거리로 갱신
            distance[next_node] = new_dist
            # next_node의 인접 노드들을 pq에 추가
            heappush(pq, (new_dist, next_node))
dijkstra(0)
print(distance) # [0, 2, 3, 9, 6, 10]
```